=============================
ABSTRACTION IN JAVA (COMPLETE MASTER NOTE)
 =============================

 -----------------------------
 1. OVERVIEW & DEFINITION
  -----------------------------
  DEFINITION:
   -> Abstraction is a fundamental concept of OOPS that focuses on showing
      only the essential features of an object while hiding the internal
      implementation details (background complexity) from the user.
  
  IN SIMPLE WORDS:
   -> "Displaying what is requested and hiding how it is done."
  
  REAL WORLD ANALOGY:
   1. THE CAR ACCELERATOR:
      - Essential: Press pedal -> Speed increases.
      - Hidden: Fuel injection, combustion, piston movement.
   2. ATM MACHINE:
      - Essential: Enter PIN -> Get Cash.
      - Hidden: Database verification, server connection, mechanical counting.


 -----------------------------
 2. WAYS TO ACHIEVE ABSTRACTION
  -----------------------------
  1. ABSTRACT CLASS (Partial Abstraction):
     -> Can have both abstract and concrete methods.
     -> Abstraction level: 0% to 100%.
  
  2. INTERFACE (Full Abstraction):
     -> Contains only abstract methods (traditionally).
     -> Abstraction level: 100%.


 -----------------------------
 3. TYPES OF METHODS
  -----------------------------
  A. CONCRETE METHOD
     -> A method that HAS a body `{ ... }` and implementation logic.
     -> It represents a completed action.
  
  B. ABSTRACT METHOD
     -> A method WITHOUT a body.
     -> It represents a requirement/idea to be implemented later.
     -> SYNTAX: `abstract returnType methodName();`
     -> RULES:
        1. Must use `abstract` keyword.
        2. Must end with a semicolon (`;`).
        3. Cannot have a body.


 -----------------------------
 4. ABSTRACT CLASS RULES
  -----------------------------
  DEFINITION:
   -> A class declared with the `abstract` keyword.
   -> It cannot be instantiated (cannot create objects).
  
  KEY PROPERTIES:
   1. ❌ INSTANTIATION: `new AbstractClass();` is a Compile Time Error.
   2. ✅ MEMBERS ALLOWED:
      - Abstract Methods.
      - Concrete Methods (Non-static).
      - Static Methods.
      - Variables (Static & Non-static).
      - Constructors.
      - Initializer Blocks (SIB & IIB).
   3. ✅ INHERITANCE: Must be inherited by a concrete class to be used.


 -----------------------------
 5. INHERITANCE & OVERRIDING RULES
  -----------------------------
  RULE 1: MANDATORY IMPLEMENTATION
   -> If a class inherits an abstract class, it MUST override (provide body for)
      ALL inherited abstract methods.
  
  RULE 2: THE "LAZY CHILD" (ABSTRACT CHAINING)
   -> If the child class does NOT want to override the abstract method, then
      the child class ITSELF must be declared as `abstract`.
   -> The responsibility passes to the next subclass (Grandchild).


 -----------------------------
 6. CONSTRUCTORS IN ABSTRACT CLASS (DEEP CONCEPT)
  -----------------------------
  THE QUESTION:
   -> "If we cannot create an object of an abstract class, why does Java allow
      constructors in it?"
  
  THE REASON:
   -> To initialize the variables declared in the abstract parent class.
   -> When a Child Object is created, the child's constructor calls `super()`.
   -> This executes the Abstract Parent's constructor to set up the parent's
      variables before the child uses them.
  
  CODE EXAMPLE:
   abstract class Vehicle {
       String brand;
       Vehicle(String b) { this.brand = b; } // Parent Constructor
   }
   class Car extends Vehicle {
       Car() { super("Audi"); } // Calls Parent Constructor
   }


 -----------------------------
 7. ILLEGAL COMBINATIONS (INTERVIEW FAVORITE)
  -----------------------------
  -> The `abstract` keyword generally creates a "To-Do List" for the child class.
     It conflicts with keywords that say "Do Not Touch".
  
  1. ABSTRACT + FINAL = ❌ ILLEGAL
     -> `final` prevents overriding. `abstract` demands overriding.
     -> They are opposites.
  
  2. ABSTRACT + STATIC = ❌ ILLEGAL
     -> `static` methods belong to the class and cannot be overridden (they
        are technically "hidden"). Abstract methods need dynamic overriding.
  
  3. ABSTRACT + PRIVATE = ❌ ILLEGAL
     -> `private` methods are hidden from the child class. The child cannot
        override what it cannot see.


 -----------------------------
 8. STATIC METHODS IN ABSTRACT CLASS
  -----------------------------
  -> We can define `static` methods in an abstract class.
  -> Since we cannot create an object, we call them using the Class Name.
  
  CODE:
   abstract class Demo {
       static void show() { System.out.println("Hello"); }
   }
   // Usage: Demo.show(); (Valid)


 -----------------------------
 9. INTERESTING FACTS
  -----------------------------
  FACT 1: MAIN METHOD
   -> Can an abstract class have a main method? ✅ YES.
   -> Since `main` is static, it runs without an object.
  
  FACT 2: 0% ABSTRACTION
   -> Can an abstract class have NO abstract methods? ✅ YES.
   -> Used when you simply want to prevent object creation of a class (e.g.,
      a Helper/Utility class).
  
  FACT 3: ANONYMOUS INNER CLASS (THE LOOPHOLE)
   -> You can technically "instantiate" an abstract class by providing the
      implementation instantly using an Anonymous Inner Class.
   -> Example:
      `AbstractClass ref = new AbstractClass() { void method() {} };`


 -----------------------------
 10. COMPREHENSIVE CODE SCENARIOS (NEW)
  -----------------------------
  SCENARIO A: THE "SHAPE" ARCHITECTURE
   -> Demonstrating polymorphism with abstraction.
   
   CODE:
    abstract class Shape {
        String color;
        // Abstract Method: Logic unknown
        abstract double area();
        // Concrete Method: Logic known
        void displayColor() { System.out.println("Color: " + color); }
        // Constructor
        Shape(String c) { this.color = c; }
    }
    
    class Circle extends Shape {
        double radius;
        Circle(String c, double r) {
            super(c);
            this.radius = r;
        }
        @Override
        double area() { return 3.14 * radius * radius; }
    }
    
    class Rectangle extends Shape {
        double l, w;
        Rectangle(String c, double l, double w) {
            super(c);
            this.l = l;
            this.w = w;
        }
        @Override
        double area() { return l * w; }
    }
    
    public class Test {
        public static void main(String[] args) {
            Shape s1 = new Circle("Red", 5);
            System.out.println("Circle Area: " + s1.area());
            
            Shape s2 = new Rectangle("Blue", 4, 5);
            System.out.println("Rect Area: " + s2.area());
        }
    }

  SCENARIO B: 0% ABSTRACTION (UTILITY CLASS)
   -> Using abstract class only to restrict object creation.
   
   CODE:
    abstract class MathHelper {
        // No abstract methods here!
        static int add(int a, int b) { return a + b; }
        static int sub(int a, int b) { return a - b; }
    }
    
    class User {
        void work() {
            // MathHelper m = new MathHelper(); // ❌ ERROR: Safe!
            int x = MathHelper.add(10, 20);     // ✅ Usage
        }
    }


 -----------------------------
 11. SUMMARY TABLES (QUICK REVISION)
  -----------------------------
  
  TABLE A: WHAT IS ALLOWED IN AN ABSTRACT CLASS?
   ========================================================================
   |      MEMBER TYPE       |    ALLOWED?    |        COMMENTS            |
   |------------------------|----------------|----------------------------|
   | Instance Variables     |       ✅       | Initialized via Constructor|
   |------------------------|----------------|----------------------------|
   | Static Variables       |       ✅       | Accessed via ClassName     |
   |------------------------|----------------|----------------------------|
   | Constructors           |       ✅       | Called via super()         |
   |------------------------|----------------|----------------------------|
   | Abstract Methods       |       ✅       | Must be overridden         |
   |------------------------|----------------|----------------------------|
   | Concrete Methods       |       ✅       | Inherited as is            |
   |------------------------|----------------|----------------------------|
   | Static Methods         |       ✅       | Not inheritable (Hiding)   |
   |------------------------|----------------|----------------------------|
   | Final Methods          |       ✅       | Cannot be overridden       |
   |------------------------|----------------|----------------------------|
   | Private Methods        |       ✅       | Only for internal use      |
   ========================================================================

  TABLE B: ABSTRACT METHOD RULES CHECKLIST
   ========================================================================
   |    MODIFIER COMBINATION    |    STATUS    |         REASON           |
   |----------------------------|--------------|--------------------------|
   | public abstract ...        |      ✅      | Standard usage.          |
   |----------------------------|--------------|--------------------------|
   | protected abstract ...     |      ✅      | Allowed for subclasses.  |
   |----------------------------|--------------|--------------------------|
   | private abstract ...       |      ❌      | Private cannot be seen.  |
   |----------------------------|--------------|--------------------------|
   | static abstract ...        |      ❌      | Static cannot override.  |
   |----------------------------|--------------|--------------------------|
   | final abstract ...         |      ❌      | Final cannot override.   |
   |----------------------------|--------------|--------------------------|
   | synchronized abstract ...  |      ❌      | No body to lock on.      |
   ========================================================================